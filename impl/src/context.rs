use crate::{
    ast::{Delimiter, Field, Input},
    attr::{AttrError, Attrs, FlagOrIdent},
    generics::{ContainerGenerics, GenericInfo},
};
use quote::format_ident;
use std::collections::BTreeSet as Set;
use syn::{DeriveInput, Fields, Ident, Member, Meta, Type, Visibility};

pub struct ContextInfo<'a> {
    pub container_name: &'a Ident,
    pub container_variant: Option<&'a Ident>,
    pub container_generics: &'a ContainerGenerics<'a>,
    pub container_delimiter: Delimiter,
    pub generics: Vec<(&'a GenericInfo<'a>, bool)>,
    pub name: Ident,
    pub delimiter: Delimiter,
    pub fields: Vec<ContextField<'a>>,
    pub source_field: Option<&'a syn::Field>,
    // Option list
    pub attr: Vec<&'a Meta>,
    pub into: Vec<&'a Type>,
    pub vis: &'a Visibility,
}

pub struct ContextField<'a> {
    pub original: &'a syn::Field,
    pub attrs: &'a Attrs,
    pub name: Member,
    pub ty: FieldType,
}

pub enum FieldType {
    Generated(Ident),
    Original,
    Source,
}

#[derive(Default)]
struct ContextOpts<'a> {
    attr: Vec<&'a Meta>,
    generic: Option<bool>,
    into: Vec<&'a Type>,
    skip: Option<bool>,
    suffix: Option<&'a FlagOrIdent>,
    unit: Option<bool>,
    vis: Option<&'a Visibility>,
}

impl<'a> ContextOpts<'a> {
    fn inherit_from(mut self, attrs: &'a Attrs) -> Self {
        fn same<T>(t: T) -> T {
            t
        }

        fn copied<T: Copy>(t: &T) -> T {
            *t
        }

        macro_rules! update_opt {
            () => {};
            ($opt:ident =use $map:path, $($rest:tt)*) => {
                if self.$opt.is_none() {
                    self.$opt = attrs.$opt.as_ref().map($map);
                }
                update_opt!($($rest)*);
            };
            ($opt:ident +use $map:path, $($rest:tt)*) => {
                self.$opt.extend(attrs.$opt.iter().map($map));
                update_opt!($($rest)*);
            };
        }

        update_opt! {
            attr    +use same,
            generic =use copied,
            into    +use same,
            skip    =use copied,
            suffix  =use same,
            unit    =use copied,
            vis     =use same,
        }

        self
    }
}

impl<'a> ContextInfo<'a> {
    // Collects context types from the input, returns with an optional module.
    pub fn collect_from(input: &'a Input<'a>) -> (Option<Ident>, Vec<Self>) {
        let original;
        let attrs;
        let contexts;
        match input {
            Input::Struct(st) => {
                original = st.original;
                attrs = &st.attrs;
                contexts = Self::new(
                    (st.original, None),
                    &st.generics,
                    &st.attrs,
                    (&st.data.fields, &st.fields),
                    ContextOpts::default().inherit_from(&st.attrs),
                )
                .into_iter()
                .collect();
            }
            Input::Enum(en) => {
                original = en.original;
                attrs = &en.attrs;
                contexts = en
                    .variants
                    .iter()
                    .filter_map(|va| {
                        Self::new(
                            (en.original, Some(&va.original.ident)),
                            &en.generics,
                            &va.attrs,
                            (&va.original.fields, &va.fields),
                            ContextOpts::default()
                                .inherit_from(&va.attrs)
                                .inherit_from(&en.attrs),
                        )
                    })
                    .collect();
            }
        }
        let module = {
            use FlagOrIdent::*;
            match &attrs.module {
                // No module is generated by default.
                Some(Flag(false)) | None => None,
                Some(Ident(m)) => Some(m.clone()),
                // Use snake-case of the input name.
                Some(Flag(true)) => Some(syn::Ident::new(
                    &camel_to_snake(&original.ident.to_string()),
                    original.ident.span(),
                )),
            }
        };
        (module, contexts)
    }

    fn new(
        (container, container_variant): (&'a DeriveInput, Option<&'a Ident>),
        container_generics: &'a ContainerGenerics<'a>,
        attrs: &'a Attrs,
        (original_fields, fields): (&'a Fields, &'a [Field<'a>]),
        opts: ContextOpts<'a>,
    ) -> Option<Self> {
        if opts.skip.unwrap_or(false) {
            return None;
        }

        let generic = opts.generic.unwrap_or(true);
        let unit = opts.unit.unwrap_or(true);
        let is_transparent = matches!(attrs.error, Some(AttrError::Transparent));

        let mut selected_generics = Set::default();
        let mut context_fields = Vec::default();

        // The index of context fileds, the field source is excluded.
        let mut field_index = 0;
        let mut source_field = None;
        for field in fields {
            let name = field
                .original
                .ident
                .clone()
                .map(Member::Named)
                .unwrap_or_else(|| Member::Unnamed(field_index.into()));
            let ty;
            if source_field.is_none() && (is_transparent || field.is_source()) {
                source_field = Some(field.original);
                ty = FieldType::Source;
            } else {
                let intersection = container_generics.intersection(&field.original.ty);
                selected_generics.extend(intersection.iter().map(|g| g.order));
                // Use a generic if the field type does not contain container generics.
                ty = if intersection.is_empty() && field.attrs.generic.unwrap_or(generic) {
                    FieldType::Generated(format_ident!("__T{}", name))
                } else {
                    FieldType::Original
                };
                field_index += 1;
            }
            context_fields.push(ContextField {
                original: field.original,
                attrs: &field.attrs,
                name,
                ty,
            });
        }
        let container_delimiter = Delimiter::from_fields(original_fields);
        Some(Self {
            container_name: &container.ident,
            container_variant,
            container_generics,
            container_delimiter,
            generics: container_generics
                .iter()
                .map(|info| (info, selected_generics.contains(&info.order)))
                .collect(),
            name: {
                use FlagOrIdent::*;
                let name = container_variant.unwrap_or(&container.ident);
                match (opts.suffix, container_variant.is_some()) {
                    // By default, suffix is added to a struct,
                    (Some(Flag(false)), _) | (None, true) => name.clone(),
                    // and is not added to a variant.
                    (Some(Flag(true)), _) | (None, false) => format_ident!("{}Context", name),
                    (Some(Ident(s)), _) => format_ident!("{}{}", name, s),
                }
            },
            // Generated unit struct if empty fields.
            delimiter: if unit && field_index == 0 {
                Delimiter::None
            } else {
                container_delimiter
            },
            fields: context_fields,
            source_field,
            attr: opts.attr,
            into: opts.into,
            // Use the container visibility as default.
            vis: opts.vis.unwrap_or(&container.vis),
        })
    }
}

impl<'a> Field<'a> {
    fn is_source(&self) -> bool {
        // A field named 'source' is considered as a source field.
        self.attrs.source.is_some()
            || self.original.ident.as_ref().map(|i| i == "source") == Some(true)
    }
}

fn camel_to_snake(s: &str) -> String {
    let mut snake = String::default();
    for (i, ch) in s.char_indices() {
        if i > 0 && ch.is_ascii_uppercase() {
            snake.push('_');
        }
        snake.push(ch.to_ascii_lowercase());
    }
    snake
}
